---
layout: article
title: 什么是协程，是否可以使用 try catch 捕获异常
key: 20180909
tags:
- 中文
- Unity3D
toc: true
date: 2018-09-09 16:37:00
---
> 协程。英文名Coroutine。

<!--more-->

> Unity官方解释：
>
> 一个协程的执行可以在任何地方用yield语句来暂停，yield return的值决定了什么时候协程恢复执行。协程在协调在几帧中执行的操作时有极大的用处.协程几乎没有任何性能开销。
>
> StartCoroutine一般都会立即返回，你也以获得返回结果的值。但是这一步会等到协程结束执行才能生效。

```c#
void Start()
{
    Debug.Log("start0");
    StartCoroutine(Cor01());
    Debug.Log("start1");
}

IEnumerator Cor01()
{
    Debug.Log("Cor0");
    yield return null;
    Debug.Log("Cor1");
}

/*
Result：
start0
test0
start1
test1
*/
```

`yield return` 不同于 `return` 

`yield` 关键字向编译器指示它所在的方块是迭代器块。

### 在协程函数内部使用try-catch的问题

```c#
IEnumerator Test()
{
    yield return null;

    try
    {
        //do something
    }
    catch (System.Exception ex)
    {
        
    }
}
```

在协程中使用try-catch时会报错

```c#
Unhandled Exception: System.ArgumentException: Trying to emit a local from a different ILGenerator.
```

Google了一下

```c#
Unhandled Exception: System.ArgumentException: Trying to emit a local from a different ILGenerator.
  at System.Reflection.Emit.ILGenerator.Emit (OpCode opcode, System.Reflection.Emit.LocalBuilder local) [0x00000] in <filename unknown>:0 
  at Mono.CSharp.LocalInfo.EmitAssign (Mono.CSharp.EmitContext ec) [0x00000] in <filename unknown>:0 
  at Mono.CSharp.VariableReference.EmitAssign (Mono.CSharp.EmitContext ec, Mono.CSharp.Expression source, Boolean leave_copy, Boolean prepare_for_load) [0x00000] in <filename unknown>:0 
  at Mono.CSharp.Catch.DoEmit (Mono.CSharp.EmitContext ec) [0x00000] in <filename unknown>:0 
  at Mono.CSharp.Statement.Emit (Mono.CSharp.EmitContext ec) [0x00000] in <filename unknown>:0 
  at Mono.CSharp.TryCatch.DoEmit (Mono.CSharp.EmitContext ec) [0x00000] in <filename unknown>:0 
  at Mono.CSharp.Statement.Emit (Mono.CSharp.EmitContext ec) [0x00000] in <filename unknown>:0 
  at Mono.CSharp.Block.DoEmit (Mono.CSharp.EmitContext ec) [0x00000] in <filename unknown>:0 
  at Mono.CSharp.Block.Emit (Mono.CSharp.EmitContext ec) [0x00000] in <filename unknown>:0 
  at Mono.CSharp.Iterator.EmitMoveNext (Mono.CSharp.EmitContext ec, Mono.CSharp.Block original_block) [0x00000] in <filename unknown>:0 
  at Mono.CSharp.IteratorStatement.DoEmit (Mono.CSharp.EmitContext ec) [0x00000] in <filename unknown>:0 
  at Mono.CSharp.Statement.Emit (Mono.CSharp.EmitContext ec) [0x00000] in <filename unknown>:0 
  at Mono.CSharp.Block.DoEmit (Mono.CSharp.EmitContext ec) [0x00000] in <filename unknown>:0 
  at Mono.CSharp.Block.Emit (Mono.CSharp.EmitContext ec) [0x00000] in <filename unknown>:0 
  at Mono.CSharp.ExplicitBlock.Emit (Mono.CSharp.EmitContext ec) [0x00000] in <filename unknown>:0 
  at Mono.CSharp.ToplevelBlock.Emit (Mono.CSharp.EmitContext ec) [0x00000] in <filename unknown>:0 
  at Mono.CSharp.MethodData.Emit (Mono.CSharp.DeclSpace parent) [0x00000] in <filename unknown>:0 
  at Mono.CSharp.MethodOrOperator.Emit () [0x00000] in <filename unknown>:0 
  at Mono.CSharp.Method.Emit () [0x00000] in <filename unknown>:0 
```

编译catch块的参数赋值时引发异常，去掉参数能编译通过，绕开了这个bug。

在协程级别是没有异常处理的，非要使用可能会造成潜在的问题。建议是异常捕获可以放在协程函数的调用处进行。

最新版的Mono已经没有这个bug了，但是unity使用的是比较老的Mono，所以这个问题依然存在，看看unity的新版会不会更新Mono吧。

### ~~使用协程WaitForMillis~~

```c#
public static class Common
{
	/// <summary>
	/// 返回一个以毫秒为单位的时间 （0001-01-01 00:00:00.000 算起）
	/// </summary>
	public static long Ticks
    {
		get
        {
            return (long) (System.DateTime.UtcNow.Ticks * 0.0001f);
        }
    }
    public delegate bool CondDelegate(); 

	/// <summary>
	/// 等待指定的毫秒
	/// </summary>
    public static IEnumerator WaitForMillis(long millis, CondDelegate cond = null)
    {
    }
}

// 调用
// yield return Common.WaitForMillis (5000);
```